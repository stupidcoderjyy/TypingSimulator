public class DFABuilder {
    private final Map<NFANodeSet, Integer> nodeSetToState = new HashMap<>();
    private final List<NFANodeSet> stateToNodeSet = new ArrayList<>();
    private List<String> nodeToToken;
    private int statesCount = 1;

    private final List<Boolean> accepted = new ArrayList<>();
    private final List<int[]> goTo = new ArrayList<>();
    private final List<String> tokens = new ArrayList<>();

    private void transfer(NFANode startNode) {
        Stack<Integer> unchecked = new Stack<>();
        createState(new NFANodeSet(epsilonClosure(Set.of(startNode))), unchecked);
        while (!unchecked.empty()) {
            int curState = unchecked.pop();
            NFANodeSet curGroup = stateToNodeSet.get(curState);
            for (byte b = 0 ; b >= 0 ; b ++) {
                Set<NFANode> nextNodes = next(curGroup.nfaNodes, b);
                if (nextNodes.isEmpty()) {
                    continue;
                }
                NFANodeSet candidate = new NFANodeSet(nextNodes);
                int targetState = nodeSetToState.containsKey(candidate) ?
                        nodeSetToState.get(candidate) :
                        createState(candidate, unchecked);
                goTo.get(curState)[b] = targetState;
            }
        }
        stateToNodeSet.clear();
        nodeSetToState.clear();
    }

    private int createState(NFANodeSet g, Stack<Integer> unchecked) {
        int newId = statesCount++;
        nodeSetToState.put(g, newId);
        stateToNodeSet.add(g);
        unchecked.push(newId);
        ensureSize(statesCount);
        for (NFANode node : g.nfaNodes) {
            if (node.accepted) {
                accepted.set(newId, true);
                tokens.set(newId, nodeToToken.get(node.id));
                return newId;
            }
        }
        return newId;
    }

    private void ensureSize(int size) {
        ArrayUtil.resize(accepted, size, () -> false);
        ArrayUtil.resize(goTo, size, () -> new int[128]);
        ArrayUtil.resize(tokens, size, () -> null);
    }

    private static Set<NFANode> epsilonClosure(Set<NFANode> nodes) {
        if (nodes.isEmpty()) {
            return nodes;
        }
        Set<NFANode> result = nodes instanceof HashSet ? nodes : new HashSet<>(nodes);
        Stack<NFANode> unchecked = new Stack<>();
        unchecked.addAll(result);
        while (!unchecked.empty()) {
            NFANode cur = unchecked.pop();
            switch (cur.edgeType) {
                case NFANode.DOUBLE_EPSILON:
                    if (!result.contains(cur.next2)) {
                        unchecked.push(cur.next2);
                        result.add(cur.next2);
                    }
                case NFANode.SINGLE_EPSILON:
                    if (!result.contains(cur.next1)) {
                        unchecked.push(cur.next1);
                        result.add(cur.next1);
                    }
                break;
            }
        }
        return result;
    }

    private static Set<NFANode> next(Set<NFANode> begin, byte b) {
        Set<NFANode> result = new HashSet<>();
        begin.stream()
                .filter(n -> n.edgeType == NFANode.CHAR && n.predicate.accept(b))
                .forEach(n -> result.add(n.next1));
        return epsilonClosure(result);
    }

    private static class NFANodeSet {
        protected final Set<NFANode> nfaNodes;
        private final int hash;

        public NFANodeSet(Set<NFANode> nfaNodes) {
            this.nfaNodes = nfaNodes;
            this.hash = nfaNodes.hashCode();
        }

        @Override
        public int hashCode() {
            return hash;
        }

        @Override
        public boolean equals(Object obj) {
            return obj instanceof NFANodeSet && ((NFANodeSet) obj).nfaNodes.equals(nfaNodes);
        }

        @Override
        public String toString() {
            return nfaNodes.toString();
        }
    }

    private final List<Set<Integer>> groups = new ArrayList<>();
    private final Stack<Integer> unchecked = new Stack<>();
    private int groupCount;
    private int[] stateToGroup;

    private Set<Integer> split(Set<Integer> curGroup) {
        Set<Integer> newGroup = null;
        int std = curGroup.iterator().next();
        curGroup.remove(std);
        for (byte b = 0 ; b >= 0 ; b ++) {
            if (curGroup.isEmpty()) {
                break;
            }
            int stdTarget = stateToGroup[goTo.get(std)[b]
        }
        curGroup.add(std);
        return newGroup;
    }

}